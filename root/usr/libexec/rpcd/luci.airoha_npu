#!/bin/sh

# Airoha SoC Status RPC backend for LuCI (NPU + CPU)

. /lib/functions.sh

get_status() {
	# === NPU Status ===

	# Get NPU firmware version from the firmware binary itself
	local npu_fw="/lib/firmware/airoha/en7581_npu_rv32.bin"
	local npu_ver="Unknown"

	if [ -f "$npu_fw" ]; then
		npu_ver=$(strings "$npu_fw" 2>/dev/null | grep -oE '([0-9]+\.[0-9]+\.[0-9]+-)?TLB[0-9.]+[-_v0-9]*' | head -1)
		[ -z "$npu_ver" ] && npu_ver="Unknown"
	fi

	# Check if NPU device is bound (active)
	local npu_loaded="false"
	local npu_device=""
	local npu_driver_path="/sys/bus/platform/drivers/airoha-npu"

	if [ -d "$npu_driver_path" ]; then
		npu_device=$(ls -1 "$npu_driver_path" 2>/dev/null | grep '\.npu$' | head -1)
		if [ -n "$npu_device" ]; then
			npu_loaded="true"
		fi
	fi

	# Get NPU clock speed
	local npu_clock=0
	if [ -f "/sys/kernel/debug/clk/npu/clk_rate" ]; then
		npu_clock=$(cat /sys/kernel/debug/clk/npu/clk_rate 2>/dev/null || echo 0)
	fi

	# Count NPU cores
	local npu_cores=$(grep -c "airoha-npu-wdt" /proc/interrupts 2>/dev/null || echo 0)

	# Get offload statistics
	local offload_stats=$(cat /sys/kernel/debug/ppe/bind 2>/dev/null | awk '
	BEGIN { total_pkts=0; total_bytes=0 }
	{
		match($0, /packets=[0-9]+/)
		if (RSTART > 0) { total_pkts += substr($0, RSTART+8, RLENGTH-8) }
		match($0, /bytes=[0-9]+/)
		if (RSTART > 0) { total_bytes += substr($0, RSTART+6, RLENGTH-6) }
	}
	END { printf "%d %d", total_pkts, total_bytes }
	')
	local offload_packets=$(echo "$offload_stats" | cut -d' ' -f1)
	local offload_bytes=$(echo "$offload_stats" | cut -d' ' -f2)

	# Memory regions
	local mem_info=$(dmesg | grep "reserved mem.*npu" | head -4)
	local regions="[]"

	if [ -n "$mem_info" ]; then
		regions=$(echo "$mem_info" | awk '
		BEGIN { printf "[" }
		{
			if (NR > 1) printf ","
			match($0, /0x[0-9a-fA-F]+\.\.0x[0-9a-fA-F]+/)
			range = substr($0, RSTART, RLENGTH)
			split(range, a, "\\.\\.")

			match($0, /\([0-9]+ [KMG]i?B\)/)
			size = substr($0, RSTART+1, RLENGTH-2)

			match($0, /non-reusable [^ ]+/)
			name = substr($0, RSTART+13)
			gsub(/@.*/, "", name)

			printf "{\"name\":\"%s\",\"start\":\"%s\",\"end\":\"%s\",\"size\":\"%s\"}", name, a[1], a[2], size
		}
		END { printf "]" }
		')
	fi

	# === CPU Frequency Status ===

	local cpufreq_path="/sys/devices/system/cpu/cpufreq/policy0"
	local cpu_cur_freq=0
	local cpu_hw_freq=0
	local cpu_governor="unknown"
	local cpu_avail_governors=""
	local cpu_min_freq=0
	local cpu_max_freq=0
	local cpu_avail_freqs=""

	if [ -d "$cpufreq_path" ]; then
		cpu_cur_freq=$(cat "$cpufreq_path/scaling_cur_freq" 2>/dev/null || echo 0)
		cpu_hw_freq=$(cat "$cpufreq_path/cpuinfo_cur_freq" 2>/dev/null || echo 0)
		cpu_governor=$(cat "$cpufreq_path/scaling_governor" 2>/dev/null || echo "unknown")
		cpu_avail_governors=$(cat "$cpufreq_path/scaling_available_governors" 2>/dev/null || echo "")
		cpu_min_freq=$(cat "$cpufreq_path/scaling_min_freq" 2>/dev/null || echo 0)
		cpu_max_freq=$(cat "$cpufreq_path/scaling_max_freq" 2>/dev/null || echo 0)
		cpu_avail_freqs=$(cat "$cpufreq_path/scaling_available_frequencies" 2>/dev/null || echo "")
	fi

	# Count online CPUs
	local cpu_count=0
	if [ -d "/sys/devices/system/cpu" ]; then
		cpu_count=$(ls -d /sys/devices/system/cpu/cpu[0-9]* 2>/dev/null | wc -l)
	fi

	printf '{"npu_version":"%s","npu_loaded":%s,"npu_device":"%s","npu_clock":%d,"npu_cores":%d,"offload_packets":%d,"offload_bytes":%d,"memory_regions":%s,"cpu_cur_freq":%d,"cpu_hw_freq":%d,"cpu_governor":"%s","cpu_avail_governors":"%s","cpu_min_freq":%d,"cpu_max_freq":%d,"cpu_avail_freqs":"%s","cpu_count":%d}' \
		"${npu_ver:-Unknown}" "$npu_loaded" "${npu_device:-}" "${npu_clock:-0}" "${npu_cores:-0}" "${offload_packets:-0}" "${offload_bytes:-0}" "$regions" \
		"${cpu_cur_freq:-0}" "${cpu_hw_freq:-0}" "${cpu_governor:-unknown}" "${cpu_avail_governors:-}" "${cpu_min_freq:-0}" "${cpu_max_freq:-0}" "${cpu_avail_freqs:-}" "${cpu_count:-0}"
}

get_ppe_entries() {
	local entries_file="/sys/kernel/debug/ppe/entries"

	if [ \! -f "$entries_file" ]; then
		echo '{"entries":[]}'
		return
	fi

	awk '
	BEGIN {
		printf "{\"entries\":["
		first = 1
	}
	/^[0-9a-fA-F]+ / {
		if (first == 0) printf ","
		first = 0

		index_val = $1
		state = $2

		type = ""
		subtype = ""
		if ($3 == "IPv4" || $3 == "IPv6") {
			type = $3
			subtype = $4
		} else if ($3 == "L2B" || $4 == "L2B") {
			type = "L2B"
			subtype = ""
		} else {
			type = $3
			subtype = $4
		}

		orig = ""
		match($0, /orig=[^ ]+/)
		if (RSTART > 0) {
			orig = substr($0, RSTART+5, RLENGTH-5)
		}

		new_flow = ""
		match($0, /new=[^ ]+/)
		if (RSTART > 0) {
			new_flow = substr($0, RSTART+4, RLENGTH-4)
		}

		eth = ""
		match($0, /eth=[^ ]+/)
		if (RSTART > 0) {
			eth = substr($0, RSTART+4, RLENGTH-4)
		}

		packets = 0
		match($0, /packets=[0-9]+/)
		if (RSTART > 0) {
			packets = substr($0, RSTART+8, RLENGTH-8)
		}

		bytes = 0
		match($0, /bytes=[0-9]+/)
		if (RSTART > 0) {
			bytes = substr($0, RSTART+6, RLENGTH-6)
		}

		printf "{\"index\":\"%s\",\"state\":\"%s\",\"type\":\"%s %s\",\"orig\":\"%s\",\"new_flow\":\"%s\",\"eth\":\"%s\",\"packets\":%d,\"bytes\":%d}", \
			index_val, state, type, subtype, orig, new_flow, eth, packets, bytes
	}
	END {
		printf "]}"
	}
	' "$entries_file" 2>/dev/null || echo '{"entries":[]}'
}

case "$1" in
	list)
		echo '{"getStatus":{},"getPpeEntries":{}}'
		;;
	call)
		case "$2" in
			getStatus)
				get_status
				;;
			getPpeEntries)
				get_ppe_entries
				;;
			*)
				echo '{"error":"Invalid method"}'
				;;
		esac
		;;
esac
